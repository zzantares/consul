---
layout: docs
page_title: Monitor Services - Check Definitions
description: >-
  One of the primary roles of the agent is management of system- and
  application-level health checks. A health check is considered to be
  application-level if it is associated with a service. A check is defined in a
  configuration file or added at runtime over the HTTP interface.
---

# Checks

One of the primary roles of the agent is management of system-level and application-level health
checks. A health check is considered to be application-level if it is associated with a
service. If not associated with a service, the check monitors the health of the entire node.

Review the [service health checks tutorial](https://learn.hashicorp.com/tutorials/consul/service-registration-health-checks)
to get a more complete example on how to leverage health check capabilities in Consul.

## Registering a Health Check

The [service health checks tutorial](https://learn.hashicorp.com/tutorials/consul/service-registration-health-checks)
shows three ways to register a service with one
[or more](#multiple-check-definitions) health checks:
1. [On Consul agent start or reload in a service definition file](https://learn.hashicorp.com/tutorials/consul/service-registration-health-checks#register-a-node-check-using-the-configuration-directory),
   located in the agent's [`-config-dir`](/docs/agent/config/cli-flags#_config_dir)
1. [Via HTTP API call in the JSON request body](https://learn.hashicorp.com/tutorials/consul/service-registration-health-checks#register-the-dashboard-service-and-check-using-the-api)
1. [Via CLI command in a service definition file](https://learn.hashicorp.com/tutorials/consul/service-registration-health-checks#register-the-counting-service-and-check-using-the-cli)

When a service is registered via HTTP API or CLI command,
the checks persist in the Consul data folder through a Consul agent restart.

## Types of Checks

This section covers the available types of health checks that can be used to
automatically monitor the health of a service instance or node.

-> **To manually mark a service unhealthy:** Use the maintenance mode
  [CLI command](/commands/maint) or
  [HTTP API endpoint](/api-docs/agent#enable-maintenance-mode)
  to temporarily remove a service instance, or all service instances on a node,
  from service discovery DNS and HTTP API query results.

### Script + Interval

These checks depend on invoking an external application
that performs the health check, exits with an appropriate exit code, and potentially
generates some output. A script is paired with an invocation interval (e.g.
every 30 seconds). This is similar to the Nagios plugin system. The output of
a script check is limited to 4KB. Output larger than this will be truncated.
By default, Script checks will be configured with a timeout equal to 30 seconds.
It is possible to configure a custom Script check timeout value by specifying the
`timeout` field in the check definition. When the timeout is reached on Windows,
Consul will wait for any child processes spawned by the script to finish. For any
other system, Consul will attempt to force-kill the script and any child processes
it has spawned once the timeout has passed.

Script checks are not enabled by default. To use them you
can either use:

- [`enable_local_script_checks`](/docs/agent/config/cli-flags#_enable_local_script_checks):
  enable script checks defined in local config files. Script checks defined via the HTTP
  API will not be allowed.
- [`enable_script_checks`](/docs/agent/config/cli-flags#_enable_script_checks): enable
  script checks regardless of how they are defined.

~> **Security Warning:** Enabling script checks in some configurations may
introduce a remote execution vulnerability which is known to be targeted by
malware. We strongly recommend `enable_local_script_checks` instead. See [this
blog post](https://www.hashicorp.com/blog/protecting-consul-from-rce-risk-in-specific-configurations)
for more details.

This is a sample script check definition:

<CodeTabs heading="Script Check">

```hcl
check = {
  id = "mem-util"
  name = "Memory utilization"
  args = ["/usr/local/bin/check_mem.py", "-limit", "256MB"]
  interval = "10s"
  timeout = "1s"
}
```

```json
{
  "check": {
    "id": "mem-util",
    "name": "Memory utilization",
    "args": ["/usr/local/bin/check_mem.py", "-limit", "256MB"],
    "interval": "10s",
    "timeout": "1s"
  }
}
```

</CodeTabs>

#### Check Script Conventions

A check script is generally free to do anything to determine the status of the check.
Consul's only requirement is that the script's exit codes must obey this convention:

- Exit code 0 - Check is passing
- Exit code 1 - Check is warning
- Any other code - Check is failing

Any output of the script will be captured and made available in the
`Output` field of checks included in HTTP API responses,
as in this example from the [local service health endpoint](/api-docs/agent/service#by-name-json).

### HTTP + Interval

These checks make an HTTP `GET` request to the specified URL,
waiting the specified `interval` amount of time between requests (eg. 30 seconds).
The status of the service depends on the HTTP response code: any `2xx` code is
considered passing, a `429 Too ManyRequests` is a warning, and anything else is
a failure. This type of check
should be preferred over a script that uses `curl` or another external process
to check a simple HTTP operation. By default, HTTP checks are `GET` requests
unless the `method` field specifies a different method. Additional header
fields can be set through the `header` field which is a map of lists of
strings, e.g. `{"x-foo": ["bar", "baz"]}`. By default, HTTP checks will be
configured with a request timeout equal to 10 seconds.

It is possible to configure a custom HTTP check timeout value by
specifying the `timeout` field in the check definition. The output of the
check is limited to roughly 4KB. Responses larger than this will be truncated.
HTTP checks also support TLS. By default, a valid TLS certificate is expected.
Certificate verification can be turned off by setting the `tls_skip_verify`
field to `true` in the check definition. When using TLS, the SNI will be set
automatically from the URL if it uses a hostname (as opposed to an IP address);
the value can be overridden by setting `tls_server_name`.

Consul follows HTTP redirects by default. Set the `disable_redirects` field to
`true` to disable redirects.

This is a sample HTTP check definition:

<CodeTabs heading="HTTP Check">

```hcl
check = {
  id = "api"
  name = "HTTP API on port 5000"
  http = "https://localhost:5000/health"
  tls_server_name =  ""
  tls_skip_verify = false
  method = "POST"
  header = {
     Content-Type = ["application/json"]
  }
  body = "{\"method\":\"health\"}"
  disable_redirects = true
  interval = "10s"
  timeout = "1s"
}
```

```json
{
  "check": {
    "id": "api",
    "name": "HTTP API on port 5000",
    "http": "https://localhost:5000/health",
    "tls_server_name": "",
    "tls_skip_verify": false,
    "method": "POST",
    "header": { "Content-Type": ["application/json"] },
    "body": "{\"method\":\"health\"}",
    "interval": "10s",
    "timeout": "1s"
  }
}
```

</CodeTabs>

### TCP + Interval

These checks make a TCP connection attempt to the specified
IP/hostname and port, waiting `interval` amount of time between attempts
(e.g. 30 seconds). If no hostname
is specified, it defaults to "localhost". The status of the service depends on
whether the connection attempt is successful (ie - the port is currently
accepting connections). If the connection is accepted, the status is
`success`, otherwise the status is `critical`. In the case of a hostname that
resolves to both IPv4 and IPv6 addresses, an attempt will be made to both
addresses, and the first successful connection attempt will result in a
successful check. This type of check should be preferred over a script that
uses `netcat` or another external process to check a simple socket operation.
By default, TCP checks will be configured with a request timeout of 10 seconds.
It is possible to configure a custom TCP check timeout value by specifying the
`timeout` field in the check definition.

This is a sample TCP check definition:

<CodeTabs heading="TCP Check">

```hcl
check = {
  id = "ssh"
  name = "SSH TCP on port 22"
  tcp = "localhost:22"
  interval = "10s"
  timeout = "1s"
}
```

```json
{
  "check": {
    "id": "ssh",
    "name": "SSH TCP on port 22",
    "tcp": "localhost:22",
    "interval": "10s",
    "timeout": "1s"
  }
}
```

</CodeTabs>

### UDP + Interval

These checks direct the client to periodically send UDP datagrams
to the specified IP/hostname and port. The duration specified in the `interval` field sets the amount of time 
between attempts, such as `30s` to indicate 30 seconds. The check is logged as healthy if any response from the UDP server is received. Any other result sets the status to `critical`.
The default interval for, UDP checks is `10s`, but you can configure a custom UDP check timeout value by specifying the
`timeout` field in the check definition. If any timeout on read exists, the check is still considered healthy.

This is a sample UDP check definition:

<CodeTabs heading="UDP Check">

```hcl
check = {
  id = "dns"
  name = "DNS UDP on port 53"
  udp = "localhost:53"
  interval = "10s"
  timeout = "1s"
}
```

```json
{
  "check": {
    "id": "dns",
    "name": "DNS UDP on port 53",
    "udp": "localhost:53",
    "interval": "10s",
    "timeout": "1s"
  }
}
```

</CodeTabs>

### Time to Live (TTL) ((#ttl))

These checks retain their last known state
for a given TTL. The state of the check must be updated periodically over the HTTP
interface. If an external system fails to update the status within a given TTL,
the check is set to the failed state. This mechanism, conceptually similar to a
dead man's switch, relies on the application to directly report its health. For
example, a healthy app can periodically `PUT` a status update to the HTTP endpoint;
if the app fails, the TTL will expire and the health check enters a critical state.
The endpoints used to update health information for a given check are: [pass](/api-docs/agent/check#ttl-check-pass),
[warn](/api-docs/agent/check#ttl-check-warn), [fail](/api-docs/agent/check#ttl-check-fail),
and [update](/api-docs/agent/check#ttl-check-update). TTL checks also persist their
last known status to disk. This allows the Consul agent to restore the last known
status of the check across restarts. Persisted check status is valid through the
end of the TTL from the time of the last check.

To manually mark a service unhealthy,
it is far more convenient to use the maintenance mode
[CLI command](/commands/maint) or
[HTTP API endpoint](/api-docs/agent#enable-maintenance-mode)
rather than a TTL health check with arbitrarily high `ttl`.

This is a sample TTL check definition:

<CodeTabs heading="TTL Check">

```hcl
check = {
  id = "web-app"
  name = "Web App Status"
  notes = "Web app does a curl internally every 10 seconds"
  ttl = "30s"
}
```

```json
{
  "check": {
    "id": "web-app",
    "name": "Web App Status",
    "notes": "Web app does a curl internally every 10 seconds",
    "ttl": "30s"
  }
}
```

</CodeTabs>

### Docker + Interval

These checks depend on invoking an external application which
is packaged within a Docker Container. The application is triggered within the running
container via the Docker Exec API. We expect that the Consul agent user has access
to either the Docker HTTP API or the unix socket. Consul uses `$DOCKER_HOST` to
determine the Docker API endpoint. The application is expected to run, perform a health
check of the service running inside the container, and exit with an appropriate exit code.
The check should be paired with an invocation interval. The shell on which the check
has to be performed is configurable which makes it possible to run containers which
have different shells on the same host. Check output for Docker is limited to
4KB. Any output larger than this will be truncated. In Consul 0.9.0 and later, the agent
must be configured with [`enable_script_checks`](/docs/agent/config/cli-flags#_enable_script_checks)
set to `true` in order to enable Docker health checks.

This is a sample Docker check definition:

<CodeTabs heading="Docker Check">

```hcl
check = {
  id = "mem-util"
  name = "Memory utilization"
  docker_container_id = "f972c95ebf0e"
  shell = "/bin/bash"
  args = ["/usr/local/bin/check_mem.py"]
  interval = "10s"
}
```

```json
{
  "check": {
    "id": "mem-util",
    "name": "Memory utilization",
    "docker_container_id": "f972c95ebf0e",
    "shell": "/bin/bash",
    "args": ["/usr/local/bin/check_mem.py"],
    "interval": "10s"
  }
}
```

</CodeTabs>

### gRPC + Interval

These checks are intended for applications that support the standard
[gRPC health checking protocol](https://github.com/grpc/grpc/blob/master/doc/health-checking.md).
The state of the check will be updated by probing the configured endpoint, waiting `interval`
amount of time between probes (eg. 30 seconds). By default, gRPC checks will be configured
with a default timeout of 10 seconds.
It is possible to configure a custom timeout value by specifying the `timeout` field in
the check definition. gRPC checks will default to not using TLS, but TLS can be enabled by
setting `grpc_use_tls` in the check definition. If TLS is enabled, then by default, a valid
TLS certificate is expected. Certificate verification can be turned off by setting the
`tls_skip_verify` field to `true` in the check definition.
To check on a specific service instead of the whole gRPC server, add the service identifier after the `gRPC` check's endpoint in the following format `/:service_identifier`.

This is a sample gRPC check for a whole application:

<CodeTabs heading="gRPC Check">

```hcl
check = {
  id = "mem-util"
  name = "Service health status"
  grpc = "127.0.0.1:12345"
  grpc_use_tls = true
  interval = "10s"
}
```

```json
{
  "check": {
    "id": "mem-util",
    "name": "Service health status",
    "grpc": "127.0.0.1:12345",
    "grpc_use_tls": true,
    "interval": "10s"
  }
}
```

</CodeTabs>

This is a sample gRPC check for the specific `my_service` service:

<CodeTabs heading="gRPC Specific Service Check">

```hcl
check = {
  id = "mem-util"
  name = "Service health status"
  grpc = "127.0.0.1:12345/my_service"
  grpc_use_tls = true
  interval = "10s"
}
```

```json
{
  "check": {
    "id": "mem-util",
    "name": "Service health status",
    "grpc": "127.0.0.1:12345/my_service",
    "grpc_use_tls": true,
    "interval": "10s"
  }
}
```

</CodeTabs>

### H2ping + Interval

These checks test an endpoint that uses http2
by connecting to the endpoint and sending a ping frame. TLS is assumed to be configured by default.
To disable TLS and use h2c, set `h2ping_use_tls` to `false`. If the ping is successful
within a specified timeout, then the check is updated as passing.
The timeout defaults to 10 seconds, but is configurable using the `timeout` field. If TLS is enabled a valid
certificate is required, unless `tls_skip_verify` is set to `true`.
The check will be run on the interval specified by the `interval` field.

This is a sample h2ping check definition:

<CodeTabs heading="H2ping Check">

```hcl
check = {
  id = "h2ping-check"
  name = "h2ping"
  h2ping = "localhost:22222"
  interval = "10s"
  h2ping_use_tls = false
}
```

```json
{
  "check": {
    "id": "h2ping-check",
    "name": "h2ping",
    "h2ping": "localhost:22222",
    "interval": "10s",
    "h2ping_use_tls": false
  }
}
```

</CodeTabs>

### Alias

These checks alias the health state of another registered
node or service. The state of the check will be updated asynchronously, but is
nearly instant. For aliased services on the same agent, the local state is monitored
and no additional network resources are consumed. For other services and nodes,
the check maintains a blocking query over the agent's connection with a current
server and allows stale requests. If there are any errors in watching the aliased
node or service, the check state will be critical. For the blocking query, the
check will use the ACL token set on the service or check definition or otherwise
will fall back to the default ACL token set with the agent (`acl_token`).

~> Configuration info: The alias check configuration expects the alias to be
registered on the same agent as the one you are aliasing. If the service is
not registered with the same agent, `"alias_node": "<node_id>"` must also be
specified. When using `alias_node`, if no service is specified, the check will
alias the health of the node. If a service is specified, the check will alias
the specified service on this particular node.

This is a sample alias check for a local service:

<CodeTabs heading="Alias Check">

```hcl
check = {
  id = "web-alias"
  alias_service = "web"
}
```

```json
{
  "check": {
    "id": "web-alias",
    "alias_service": "web"
  }
}
```

</CodeTabs>

## Check Definition

This section covers some of the most common options for check definitions.
For a complete listing of all check options, refer to the
[Register Check HTTP API endpoint documentation](/api-docs/agent/check#json-request-body-schema).

-> **Casing for Check Options:**
   The correct casing for an option depends the check is defined
   in a service definition file (e.g., `deregister_critical_service_after`)
   or an HTTP API JSON request body (e.g., `DeregisterCriticalServiceAfter`).

#### General Options

- `name` `(string: <required>)` - Specifies the name of the check.

- `id` `(string: "")` - Specifies a unique ID for this check on this node.
  
  If unspecified, Consul defines the check id by:
  - If the check definition is embedded within a service definition file,
     a unique check id is auto-generated.
  - Otherwise, the `id` is set to the value of `name`.
    If names might conflict, unique IDs must be provided to avoid
    overwriting existing checks with the same id on this node.

- `interval` `(string: <required for interval-based checks>)` - Specifies
  the frequency at which to run this check.
  Required for _* + Interval_ check types, including
  script, TCP, UDP, HTTP, Docker, gRPC, and h2ping checks.

  The value is parsed by Go's `time` package, and has the following
  [formatting specification](https://golang.org/pkg/time/#ParseDuration):

  > A duration string is a possibly signed sequence of decimal numbers, each with
  > optional fraction and a unit suffix, such as "300ms", "-1.5h" or "2h45m".
  > Valid time units are "ns", "us" (or "µs"), "ms", "s", "m", "h".

- `service_id` `(string: <required for service health checks>)` - Specifies
  the ID of a service instance to associate this check with.
  That service instance must be on this node.
  If not specified, this check is treated as a node-level check.
  For more information, refer to the
  [service-bound checks](#service-bound-checks) section.

- `status` `(string: "")` - Specifies the initial status of the health check as
   "critical" (default), "warning", or "passing". For more details, refer to
   the [initial health check status](#initial-health-check-status) section.
  
  -> **Health defaults to critical:** If health status it not initially specified,
     it defaults to "critical" to protect against including a service
     in discovery results before it is ready. 

- `deregister_critical_service_after` `(string: "")` - If specified,
  the associated service (and all of its associated checks) will be deregistered
  if this check is in the critical state for more than the specified value.
  The value has the same formatting specification as the [`interval`](#interval) field.

  The minimum timeout is 1 minute,
  and the process that reaps critical services runs every 30 seconds,
  so it may take slightly longer than the configured timeout to trigger the deregistration.
  This should generally be configured with a timeout that's much, much longer than
  any expected recoverable outage for the given service.

- `notes` `(string: "")` - Provides a human-readable description of the check.
  This field is opaque to Consul and can be used however is useful to the user.
  For example, it could be used to describe the current state of the check.

- `token` `(string: "")` - Specifies an ACL token used for any interaction
  with the catalog for the check, including
  [anti-entropy syncs](/docs/architecture/anti-entropy) and deregistration.

  For Alias checks, this token is used if a remote blocking query is necessary to watch the state of the aliased node or service.

#### Success/Failures before passing/warning/critical

To prevent flapping health checks, and limit the load they cause on the cluster,
a health check may be configured to become passing/warning/critical only after a
specified number of consecutive checks return passing/critical.
The status will not transition states until the configured threshold is reached.

- `success_before_passing` - Number of consecutive successful results required
  before check status transitions to passing. Defaults to `0`. Added in Consul 1.7.0.

- `failures_before_warning` - Number of consecutive unsuccessful results required
  before check status transitions to warning. Defaults to the same value as that of
  `failures_before_critical` to maintain the expected behavior of not changing the
  status of service checks to `warning` before `critical` unless configured to do so.
  Values higher than `failures_before_critical` are invalid. Added in Consul 1.11.0.

- `failures_before_critical` - Number of consecutive unsuccessful results required
  before check status transitions to critical. Defaults to `0`. Added in Consul 1.7.0.

This feature is available for HTTP, TCP, gRPC, Docker & Monitor checks.
By default, both passing and critical thresholds will be set to 0 so the check
status will always reflect the last check result.

<CodeTabs heading="Flapping Prevention Example">

```hcl
checks = [
  {
    name = "HTTP TCP on port 80"
    tcp = "localhost:80"
    interval = "10s"
    timeout  = "1s"
    success_before_passing =  3
    failures_before_warning =  1
    failures_before_critical =  3
  }
]
```

```json
{
  "checks": [
    {
      "name": "HTTP TCP on port 80",
      "tcp": "localhost:80",
      "interval": "10s",
      "timeout": "1s",
      "success_before_passing": 3,
      "failures_before_warning": 1,
      "failures_before_critical": 3
    }
  ]
}
```

</CodeTabs>

## Initial Health Check Status

By default, when checks are registered against a Consul agent, the state is set
immediately to "critical". This is useful to prevent services from being
registered as "passing" and entering the service pool before they are confirmed
to be healthy. In certain cases, it may be desirable to specify the initial
state of a health check. This can be done by specifying the `status` field in a
health check definition, like so:

<CodeTabs heading="Status Field Example">

```hcl
check = {
  id = "mem"
  args = ["/bin/check_mem", "-limit", "256MB"]
  interval = "10s"
  status = "passing"
}
```

```json
{
  "check": {
    "id": "mem",
    "args": ["/bin/check_mem", "-limit", "256MB"],
    "interval": "10s",
    "status": "passing"
  }
}
```

</CodeTabs>

The above service definition would cause the new "mem" check to be
registered with its initial state set to "passing".

## Service-bound checks

Health checks may optionally be bound to a specific service. This ensures
that the status of the health check will only affect the health status of the
given service instead of the entire node. Service-bound health checks may be
provided by adding a `service_id` field to a check configuration:

<CodeTabs heading="Status Field Example">

```hcl
check = {
  id = "web-app"
  name = "Web App Status"
  service_id = "web-app"
  ttl = "30s"
}
```

```json
{
  "check": {
    "id": "web-app",
    "name": "Web App Status",
    "service_id": "web-app",
    "ttl": "30s"
  }
}
```

</CodeTabs>

In the above configuration, if the web-app health check begins failing, it will
only affect the availability of the web-app service. All other services
provided by the node will remain unchanged.

## Agent Certificates for TLS Checks

The [enable_agent_tls_for_checks](/docs/agent/config/config-files#enable_agent_tls_for_checks)
agent configuration option can be utilized to have HTTP or gRPC health checks
to use the agent's credentials when configured for TLS.

## Multiple Check Definitions

Multiple check definitions can be defined using the `checks` (plural)
key in your configuration file.

<CodeTabs heading="Multiple Checks Example">

```hcl
checks = [
  {
    id       = "chk1"
    name     = "mem"
    args     = ["/bin/check_mem", "-limit", "256MB"]
    interval = "5s"
  },
  {
    id       = "chk2"
    name     = "/health"
    http     = "http://localhost:5000/health"
    interval = "15s"
  },
  {
    id       = "chk3"
    name     = "cpu"
    args     = ["/bin/check_cpu"]
    interval = "10s"
  },
  ...
]
```

```json
{
  "checks": [
    {
      "id": "chk1",
      "name": "mem",
      "args": ["/bin/check_mem", "-limit", "256MB"],
      "interval": "5s"
    },
    {
      "id": "chk2",
      "name": "/health",
      "http": "http://localhost:5000/health",
      "interval": "15s"
    },
    {
      "id": "chk3",
      "name": "cpu",
      "args": ["/bin/check_cpu"],
      "interval": "10s"
    },
    ...
  ]
}
```

</CodeTabs>
